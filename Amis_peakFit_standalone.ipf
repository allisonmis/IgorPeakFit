#pragma TextEncoding = "UTF-8"
#pragma rtGlobals=3		
// Combi pseudovoigt fitting code by Allison Mis (allison.mis@gmail.com)
// 
// For a single 1D trace (sample), use "SingleTraceXRDParamGenerator" to pre-populate W-coef with initial guesses, then use Igor fitting to fit to AutoCubicPseudoVoigts
// To fit a 2D wave containing multiple traces (library), use "LibraryXRDPeakFit"
// "XRDCompare" will fit multiple 2D waves and plot the results for comparison
//  "StandardizeMarkersAndColors" can be used to change the appearance of multiple plots simultaneously (use on plots generated by XRDCompare or XRDPeakFitPlotter)




// Populates W_coef with initial guesses, wEps, and T_constraints for a single sample's XRD pattern. 
//
// input wXRDint: 1d wave of intensity values, should be BG subtracted already.
// input sPeakPositions: list of peak position wave x indices, (NOT 2th) separated by ';' 
// input sProjectName: name of COMBIgor project of interest
// input vWindowSize: number of points peak can be (+/-) from given x index position; defaults to 10
// input vFwhmGuess: initial guess for FWHM in pseudo-voigt fit; defaults to 4 points
// input vFracGaussGuess: initial guess for Gaussian vs Lorentzian weighting in pseudo-voigt fit; defaults to .5
// input vEpsPoly: epsilon wave value for polynomial background terms in pseudo-voigt fit; defaults to 1e-9
// input vEpsAmp: epsilon wave value for peak amplitude terms in pseudo-voigt fit; defaults to 1e-6
// input vEpsFWHM: epsilon wave value for FWHM terms in pseudo-voigt fit; defaults to 1e-7
// input vEpsCenter: epsilon wave value for peak location terms in pseudo-voigt fit; defaults to 1e-7
// input vEpsFracGauss: epsilon wave value for Gaussian vs Lorentzian weighting in pseudo-voigt fit; defaults to 1e-9
//
// output sFittedPeakIndices: a list of which peaks (indices of the list sPeakPositions) have been given initial guesses

Function/S singleTraceXRDParamGenerator(wXRDint, sPeakPositions,  [vWindowSize, vFwhmGuess, vMaxFwhm, vFracGaussGuess, vEpsPoly, vEpsAmp, vEpsFWHM, vEpsCenter, vEpsFracGauss])
	wave wXRDint
	string sPeakPositions
	variable vWindowSize, vFwhmGuess, vMaxFwhm, vFracGaussGuess, vEpsPoly, vEpsAmp, vEpsFWHM, vEpsCenter, vEpsFracGauss
	
	// clean up input list
	sPeakPositions = replaceString(",", sPeakPositions, ";")
	
	// establish default values if optional variables undefined
	vWindowSize = ParamIsDefault(vWindowSize) ? 10:vWindowSize
	vFwhmGuess = ParamIsDefault(vFwhmGuess) ? 4:vFwhmGuess
	vMaxFwhm = ParamIsDefault(vMaxFwhm) ? 40:vMaxFwhm
	vFracGaussGuess = ParamIsDefault(vFracGaussGuess) ? .5:vFracGaussGuess
	vEpsPoly = ParamIsDefault(vEpsPoly) ? 1e-9:vEpsPoly
	vEpsAmp = ParamIsDefault(vEpsAmp) ? 1e-6:vEpsAmp
	vEpsFWHM = ParamIsDefault(vEpsFWHM) ? 1e-7:vEpsFWHM
	vEpsCenter = ParamIsDefault(vEpsCenter) ? 1e-7:vEpsCenter
	vEpsFracGauss = ParamIsDefault(vEpsFracGauss) ? 1e-9:vEpsFracGauss
	
	// duplicate input wave, smooth with boxcar
	if(!WaveExists(wXRDint))
		print "Wave "+nameOfWave(wXRDint)+" does not exist."
		return ""
	endIf
	Duplicate/O wXRDint SmoothXRD
	wave wSmoothXRD = $("root:SmoothXRD")
	Smooth/B 10, wSmoothXRD
	
	// make strings that will create output string
	variable vNumPeaks = itemsInList(sPeakPositions)
	string sTrustedPeakIndices = ""
	variable iPeakList
	for(iPeakList=0; iPeakList<vNumPeaks; iPeakList+=1)
		sTrustedPeakIndices += num2Str(iPeakList)+";"
	endFor
	string  sFittedPeakIndices = ""
	
	// preliminary fit for background, clear out w_coef, subtract BG from smoothXRD
	Duplicate/O wXRDint $("root:XRD_PeakFit:Trash:BG_for_initial_guess")
	wave wBGnoPeaks = $("root:XRD_PeakFit:Trash:BG_for_initial_guess")
	Duplicate/O wBGnoPeaks $("root:XRD_PeakFit:Trash:BG_fit")
	wave wBGfit = $("root:XRD_PeakFit:Trash:BG_fit")
	for(iPeakList=0; iPeakList<vNumPeaks; iPeakList+=1)
		variable vCurrentPeak = str2Num(StringFromList(iPeakList, sPeakPositions))
		wBGnoPeaks[vCurrentPeak-3*vWindowSize,vCurrentPeak+3*vWindowSize] = NaN
	endFor
	CurveFit/Q poly 4, wBGnoPeaks /D=root:XRD_PeakFit:Trash:BG_fit
	wave/D w_coef = root:w_coef
	variable vX0coef=w_coef[0], vX1coef=w_coef[1], vX2coef=w_coef[2], vX3coef=w_coef[3]
	wBGfit = vX0coef + x*vX1coef + x^2*vX2coef + x^3*vX3coef
	wSmoothXRD = wSmoothXRD-wBGfit
	Make/D/O/N=(1) W_coef; W_coef = 0
	Make/O/N=(1) wEpsilon; wEpsilon = vEpsPoly //todo: put in trash folder
	
	string sPeakIndicesToConstrain = ""
	// cycle through given list of peaks
	for(iPeakList=0; iPeakList<vNumPeaks; iPeakList+=1)
		variable vCurrentPeakPos = str2num(stringFromList(iPeakList, sPeakPositions))
		
		// check that the derivatives indicate this peak is its own peak 
		// (done first to keep wavestats results for wSmoothXRD)
		// If necessary,remove neighbor from trusted list, add to trash list
		variable vTrustworthyPeak = IsThisPeakItsOwnPeak(wSmoothXRD, vCurrentPeakPos, vWindowSize)
		if(vTrustworthyPeak==1 || vTrustWorthyPeak==-1)
			sTrustedPeakIndices = removeFromList(num2Str(iPeakList+vTrustworthyPeak), sTrustedPeakIndices)
			sTrustedPeakIndices = removeFromList(num2Str(iPeakList), sTrustedPeakIndices)
		endIf	
		
		// check there is a peak shape (ignore height) within the window around the given x point
		waveStats/Q/R=[vCurrentPeakPos-vWindowSize,vCurrentPeakPos+vWindowSize] wSmoothXRD
		if(vTrustworthyPeak==2) 
			sTrustedPeakIndices = removeFromList(num2Str(iPeakList), sTrustedPeakIndices)
		else
			// put parameter guesses into W_coef
			variable vWcoefLength = numPnts(W_coef)
			redimension/N=(vWcoefLength+4) W_coef 
			W_coef[vWcoefLength+1] = V_maxloc
			W_coef[vWcoefLength+3] = vFracGaussGuess
			sFittedPeakIndices += num2str(iPeakList)+";"
			if(WhichListItem(num2str(iPeakList), sTrustedPeakIndices) == -1)
				W_coef[vWcoefLength] = V_max
				W_coef[vWcoefLength+2] = vFwhmGuess*2
				sPeakIndicesToConstrain += num2Str(NaN)+";"
			else
				W_coef[vWcoefLength] = V_max*2
				W_coef[vWcoefLength+2] = vFwhmGuess
				sPeakIndicesToConstrain += num2str(iPeakList)+";"
			endIf
			// build epsilon wave
			variable vEpsLength = numPnts(wEpsilon)
			redimension/N=(vEpsLength+4) wEpsilon
			wEpsilon[vEpsLength] = vEpsAmp
			wEpsilon[vEpsLength+1] = vEpsCenter
			wEpsilon[vEpsLength+2] = vEpsFWHM
			wEpsilon[vEpsLength+3] = vEpsFracGauss
		endIf
	endfor
	
	// add on polynomial terms for background + epsilon wave
	vWcoefLength = numPnts(W_coef)
	redimension/N=(vWcoefLength+3) W_coef
	W_coef[0] = vX0coef
	W_coef[vWcoefLength] = vX1coef
	W_coef[vWcoefLength+1] = vX2coef
	W_coef[vWcoefLength+2] = vX3coef
	vEpsLength = numPnts(wEpsilon)
	redimension/N=(vEpsLength+3) wEpsilon
	wEpsilon[vEpsLength] = vEpsPoly
	wEpsilon[vEpsLength+1] = vEpsPoly
	wEpsilon[vEpsLength+2] = vEpsPoly
	
	
	// make constraint waves
	makeXRDConstraintWave(sPeakIndicesToConstrain, vMaxFwhm,vWindowSize)
	
	// clean up TODO
	KillWaves/Z $nameOfWave(wSmoothXRD), bgFit
	
	return sFittedPeakIndices
End


// Populates a text wave of constraints (T_constraints) for the given peak indices based on fit parameters in W_coef
// Assumes W_coef is y0 + numPeaks*(Amp, Center, FWHM, fracGauss)
//
// input sPeakIndicesToConstrain: list of which sets of W_coef variables to make bounds for
// input vMaxFwhm: maximum value (in points) of constrained peak FWHMs
// input vWindowSize: allowed range of values for peak location is guess +/- window size
//
// output: none

Function makeXRDConstraintWave(sPeakIndicesToConstrain, vMaxFwhm, vWindowSize)
	string sPeakIndicesToConstrain
	variable vMaxFwhm, vWindowSize
	
	// make wave
	variable vNumPeaks = itemsInList(sPeakIndicesToConstrain)
	make/T/O/N=(0) root:T_Constraints
	wave/T T_Constraints = root:T_Constraints
	wave/D W_coef = root:W_coef
	
	// cycle through given peak indices, populate 6 constraints for each non-Nan
	// fGauss constrained between 0, 1, peak center +/-, FWHM +/-
	variable iPeakList
	for(iPeakList=0; iPeakList<vNumPeaks; iPeakList+=1)
		variable vAmp = W_coef[4*iPeakList+1]
		variable vPeakCenter = W_coef[4*iPeakList+2]
		variable vNumPntsOld = numPnts(T_Constraints)

		if(numType(str2num(stringFromList(iPeakList, sPeakIndicesToConstrain))) !=2)
				Redimension/N=(vNumPntsOld+7) T_constraints //
				// amp
				T_Constraints[vNumPntsOld] = "K"+num2str(4*iPeakList+1)+">1e-5" //previous index iPeakList*7
				//center
				T_Constraints[vNumPntsOld+1] = "K"+num2str(4*iPeakList+2)+">"+num2Str(vPeakCenter-2*vWindowSize)
				T_Constraints[vNumPntsOld+2] = "K"+num2str(4*iPeakList+2)+"<"+num2Str(vPeakCenter+2*vWindowSize)
				// FWHM
				T_Constraints[vNumPntsOld+3] = "K"+num2str(4*iPeakList+3)+">1e-5"
				T_Constraints[vNumPntsOld+4] = "K"+num2str(4*iPeakList+3)+"<"+num2Str(vMaxFwhm)
				// frac_gauss
				T_Constraints[vNumPntsOld+5] = "K"+num2str(4*iPeakList+4)+">-1e-5"
				T_Constraints[vNumPntsOld+6] = "K"+num2str(4*iPeakList+4)+"<1"
			else
				Redimension/N=(vNumPntsOld+6) T_constraints //
				// amp
				T_Constraints[vNumPntsOld] = "K"+num2str(4*iPeakList+1)+">1e-5"
				//center
				T_Constraints[vNumPntsOld+1] = "K"+num2str(4*iPeakList+2)+">"+num2Str(vPeakCenter-4*vWindowSize)
				T_Constraints[vNumPntsOld+2] = "K"+num2str(4*iPeakList+2)+"<"+num2Str(vPeakCenter+4*vWindowSize)
				// FWHM
				T_Constraints[vNumPntsOld+3] = "K"+num2str(4*iPeakList+3)+">1e-5"
				// frac_gauss
				T_Constraints[vNumPntsOld+4] = "K"+num2str(4*iPeakList+4)+">-1e-5"
				T_Constraints[vNumPntsOld+5] = "K"+num2str(4*iPeakList+4)+"<1"
			endIf
	endFor
End


// Function to determine if there is a peak at a given position
//
// input wXRD: 1D data wave to be examined
// input vPeakPos: index in wXRD where there may be a peak
// input vWindowSize: width of window (in # data points) around vPeakPos where peak might be
//
// returns: 0 if there could be a peak at this position
// 1 if higher index neighbor is trash
// -1 if lower index neighbor is trash
// 2 if peak should just be removed
//
// 
Function IsThisPeakItsOwnPeak(wXRD,vPeakPos, vWindowSize)
	wave wXRD
	variable vPeakPos, vWindowSize
	
	differentiate wXRD /D=wXRDdiff
	smooth/B 5, wXRDdiff
	waveStats/Q/R=[vPeakPos-vWindowSize,vPeakPos] wXRDdiff
	variable vLHSmax = V_max
	waveStats/Q/R=[vPeakPos,vPeakPos+vWindowSize] wXRDdiff
	variable vRHSmin = V_min
	
	variable vReturnVal
	if(vLHSmax>0 && vRHSmin<0)
		vReturnVal = 0		// there could be a peak in here
	elseIf(vLHSmax<0 && vRHSmin<0)
		vReturnVal = -1		// this peak is overwhelmed by the peak to the left
	elseIf(vLHSmax>0 && vRHSmin>0)
		vReturnVal = 1		// this peak is overwhelmed by the peak to the right
	else
		vReturnVal = 2		// this peak is a bowl? remove, don't touch neighbors.
	endIf
	//cleanup
	killWaves wXRDdiff
	return vReturnVal
End


// Fitting function for an arbitrary number of pseudo-Voigt peaks + a cubic background
// Calculates number of peaks based on number of points in wFitParams input
// Assumes wFitParams is y0 + nGaussians*(amp, center, width, fracGauss) + coefs for x, x^2, x^3
//
// input wFitParams: wave of initial guesses for the fit
// input x: x value of the wave (should not be 2th)
//
// output: the fit function with cubic background and arbitrarily-many peaks

Function AutoCubicPseudoVoigts(wFitParams, x) : FitFunc
	wave wFitParams
	variable x
	variable iPeak, vFunction=0, vNumPeaks = (DimSize(wFitParams,0)-4)/4 // -4 for each polynomial term
	// for each peak as determined by input fit parameters
	for(iPeak=0; iPeak<vNumPeaks; iPeak+=1)
		variable vAmp = wFitParams[1+iPeak*4]
		variable vCenter = wFitParams[2+iPeak*4]
		variable vFWHM = wFitParams[3+iPeak*4]
		variable vFracGauss = wFitParams[4+iPeak*4]
		// add the gaussian terms
		vFunction += vFracGauss*vAmp*Exp( -4*Ln(2) *((x-vCenter)/vFWHM)^2 )
		// add the lorentzian terms
		vFunction += (1-vFracGauss)*vAmp*( 1 + (2*(x-vCenter)/vFWHM)^2 )^-1
	endFor
	// add in polynomial terms
	vFunction += wFitParams[0] + wFitParams[4*vNumPeaks+1]*x + wFitParams[4*vNumPeaks+2]*x^2 + wFitParams[4*vNumPeaks+3]*x^3
	return vFunction
End


///////////////////////////////////////
// Independently fits each point in a library.
// Assumes intensity and 2th waves live in the folder FilePath:Library:
// Assumes each sample is in its own row 
// Assumes 2th wave is linearly spaced
// No duplicates allowed in 2th or peak name lists.
// Will delete any pre-existing folders in FilePath:Library:XRD_PeakFit
// Library names must not contain spaces or be entirely numeric (basically cannot require ' ' when composing file path)
//
// input sFilePath: File path to folder containing library data
// input sLibraryName: library of interest
// input s2thList: list of peak positions in 2th, separated by ';' 
// input sPeakNameList: names corresponding to each peak position given in s2thList
// Optional:
// input sXRDintWaveName: name of 2D wave containing XRD (y) data; defaults to "XRD_RawIntensity"
// input sXRD2thWaveName: name of 2D wave containing 2th (x) data; defaults to "XRD_TwoTheta"
// input vWindowSize: number of points peak can be (+/-) from given x index position; defaults to 10
// input vFwhmGuess: initial guess for FWHM in pseudo-voigt fit; defaults to 4 points
// input vMaxFWHM: max FWHM value allowed for fit params to be kept in output waves
// input vEpsPoly: epsilon wave value for polynomial background terms in pseudo-voigt fit; defaults to 1e-9
// input vEpsAmp: epsilon wave value for peak amplitude terms in pseudo-voigt fit; defaults to 1e-6
// input vEpsFWHM: epsilon wave value for FWHM terms in pseudo-voigt fit; defaults to 1e-7
// input vEpsCenter: epsilon wave value for peak location terms in pseudo-voigt fit; defaults to 1e-7
// input vEpsFracGauss: epsilon wave value for Gaussian vs Lorentzian weighting in pseudo-voigt fit; defaults to 1e-9
// input vBgScaleLocation: wave index of intensity value to use to scale background area
// input vPeakAmpScaleType: 0 for no scaled values, 1 for scale by max amp in library
//
Function LibraryXRDPeakFit(sFilePath, sLibraryName, s2thList, sPeakNameList, [sXRDintWaveName, sXRD2thWaveName, vWindowSize, vFwhmGuess, vMaxFwhm, vEpsPoly, vEpsAmp, vEpsFWHM, vEpsCenter, vEpsFracGauss, vBgScaleLocation, vPeakAmpScaleType])
	string sFilePath, sLibraryName, s2thList, sPeakNameList, sXRDintWaveName, sXRD2thWaveName
	variable vWindowSize, vFwhmGuess, vMaxFwhm, vEpsPoly, vEpsAmp, vEpsFWHM, vEpsCenter, vEpsFracGauss, vBgScaleLocation, vPeakAmpScaleType
	
	// Clean up input lists
	s2thList = replaceString(",",s2thList,";")
	s2thList = replaceString(" ",s2thList,"")
	sPeakNameList = replaceString(",",sPeakNameList,";")
	sPeakNameList = replaceString(" ",sPeakNameList,"")
	if(strlen(sFilePath)==0)
		sFilePath = "root"
	endIf

	
	// Assign undefined variable default values
	vWindowSize = ParamIsDefault(vWindowSize) ? 7:vWindowSize
	vFwhmGuess = ParamIsDefault(vFwhmGuess) ? 15:vFwhmGuess
	vMaxFwhm = ParamIsDefault(vMaxFwhm) ? 40:vMaxFwhm
	
	
	// Define XRD wave references, check correct dimensions
	if(ParamIsDefault(sXRDintWaveName))
		sXRDintWaveName = "XRD_RawIntensity"
	endIf
	if(ParamIsDefault(sXRD2thWaveName))
		sXRD2thWaveName = "XRD_TwoTheta"
	endIf
	if(WaveExists($(sFilePath+":"+sLibraryName+":"+sXRDintWaveName)))
		wave wXRDint = $(sFilePath+":"+sLibraryName+":"+sXRDintWaveName)
	else
		Print "Wave "+sXRDintWaveName+" does not exist for given file path and library." 
		return -1
	endIf
	if(WaveExists($(sFilePath+":"+sLibraryName+":"+sXRD2thWaveName)))
		wave wXRD2th = $(sFilePath+":"+sLibraryName+":"+sXRD2thWaveName)
	else
		Print "Wave "+sXRD2thWaveName+" does not exist for given file path and library."
		return -1
	endIf
	if(dimsize(wXRDint,0) != dimSize(wXRD2th,0))
		Print "X and Y waves do not have the same number of rows"
		return -1
	endIf
	if(dimsize(wXRDint,1) != dimSize(wXRD2th,1))
		Print "X and Y waves do not have the same number of columns"
		return -1
	endIf
	variable vSamplesInLibrary = dimsize(wXRDint,0)
	variable vPointsInSample = dimSize(wXRDint,1)
	
	// make root-level master folder to store all fit params/trusted peaks, one subfolder per library. 
	// Make trash folder. Make amorphous area wave.
	if(!DataFolderExists("root:XRD_PeakFit"))
		NewDataFolder root:XRD_PeakFit
	endIf
	if(!DataFolderExists("root:XRD_PeakFit:"+sLibraryName))
		NewDataFolder $("root:XRD_PeakFit:"+sLibraryName)
	endIf
	if(!DataFolderExists("root:XRD_PeakFit:Trash"))
		NewDataFolder $("root:XRD_PeakFit:Trash")
	endIf
	KillDataFolder/Z $(sFilePath+":"+sLibraryName+":XRD_PeakFit")
	NewDataFolder/O $(sFilePath+":"+sLibraryName+":XRD_PeakFit")
	Make/O/N=(vSamplesInLibrary) $(sFilePath+":"+sLibraryName+":XRD_PeakFit:BackgroundArea")
	wave wAmoBgAreas = $(sFilePath+":"+sLibraryName+":XRD_PeakFit:BackgroundArea")
	
	//For each peak index, create output waves, assign wave reference, fill waves with NaN
	variable iPeakList, iSampleNumber
	variable vNumSamples = dimSize(wXRDint,0), vNumPeaks = ItemsInList(sPeakNameList)
	make/O/wave/N=(6*vNumPeaks) wOutputWaveRefs //
	for(iPeakList=0; iPeakList<ItemsInList(sPeakNameList); iPeakList +=1)
		string sCurrentIndex = StringFromList(iPeakList, sPeakNameList)
		
		Make/O/N=(vSamplesInLibrary) $(sFilePath+":"+sLibraryName+":XRD_PeakFit:PeakAmp_"+sCurrentIndex)
		Make/O/N=(vSamplesInLibrary) $(sFilePath+":"+sLibraryName+":XRD_PeakFit:PeakCenter_"+sCurrentIndex)
		Make/O/N=(vSamplesInLibrary) $(sFilePath+":"+sLibraryName+":XRD_PeakFit:FWHM_"+sCurrentIndex)
		Make/O/N=(vSamplesInLibrary) $(sFilePath+":"+sLibraryName+":XRD_PeakFit:PeakAmpErr_"+sCurrentIndex)
		Make/O/N=(vSamplesInLibrary) $(sFilePath+":"+sLibraryName+":XRD_PeakFit:PeakCenterErr_"+sCurrentIndex)
		Make/O/N=(vSamplesInLibrary) $(sFilePath+":"+sLibraryName+":XRD_PeakFit:FwhmErr_"+sCurrentIndex)
		
		wOutputWaveRefs[6*iPeakList] = $(sFilePath+":"+sLibraryName+":XRD_PeakFit:PeakAmp_"+sCurrentIndex); wave wAmp = wOutputWaveRefs[6*iPeakList]; wAmp = NaN
		wOutputWaveRefs[6*iPeakList+1] = $(sFilePath+":"+sLibraryName+":XRD_PeakFit:PeakCenter_"+sCurrentIndex); wave wCenter = wOutputWaveRefs[6*iPeakList+1]; wCenter = NaN
		wOutputWaveRefs[6*iPeakList+2] = $(sFilePath+":"+sLibraryName+":XRD_PeakFit:FWHM_"+sCurrentIndex); wave wFWHM = wOutputWaveRefs[6*iPeakList+2]; wFWHM = NaN
		wOutputWaveRefs[6*iPeakList+3] = $(sFilePath+":"+sLibraryName+":XRD_PeakFit:PeakAmpErr_"+sCurrentIndex); wave wAmpErr = wOutputWaveRefs[6*iPeakList+3]; wAmpErr = NaN
		wOutputWaveRefs[6*iPeakList+4] = $(sFilePath+":"+sLibraryName+":XRD_PeakFit:PeakCenterErr_"+sCurrentIndex); wave wCenterErr = wOutputWaveRefs[6*iPeakList+4]; wCenterErr = NaN
		wOutputWaveRefs[6*iPeakList+5] = $(sFilePath+":"+sLibraryName+":XRD_PeakFit:FwhmErr_"+sCurrentIndex); wave wFwhmErr = wOutputWaveRefs[6*iPeakList+5]; wFwhmErr = NaN
		
	endFor
	Make/O/N=(vSamplesInLibrary,vPointsInSample) $(sFilePath+":"+sLibraryName+":XRD_PeakFit:Residuals")
	wave wResiduals = $(sFilePath+":"+sLibraryName+":XRD_PeakFit:Residuals"); wResiduals = NaN
	Make/O/N=(vSamplesInLibrary) $(sFilePath+":"+sLibraryName+":XRD_PeakFit:FitErrs")
	wave wFitErrors = $(sFilePath+":"+sLibraryName+":XRD_PeakFit:Residuals"); wFitErrors = NaN
	make/O/T/N=(vNumSamples) $("root:XRD_PeakFit:"+sLibraryName+":"+"TrustedPeaks")
	wave/T wLibraryTrustedPeaks = $("root:XRD_PeakFit:"+sLibraryName+":"+"TrustedPeaks"); wLibraryTrustedPeaks = ""
	
		
	// Determine background scale factor, if optional variable given
	if(!ParamIsDefault(vBgScaleLocation))
		if(vBgScaleLocation<DimSize(wXRDint,1))
			variable vAvgBgScale = 0 //average over library at given point
			for(iSampleNumber=0; iSampleNumber<vNumSamples; iSampleNumber+=1)
				vAvgBgScale += wXRDint[iSampleNumber][vBgScaleLocation]
			endFor
			vAvgBgScale = vAvgBgScale/vNumSamples
		else
			print "BgScaleLocation out of index for XRD intensity wave"
			return -1
		endIf
	endIf
	
	
	// Convert given 2th values to x indices
	wave wOneD2th = $ExtractASampleFromAVector(sFilePath+":"+sLibraryName, sXRD2thWaveName, 0, sXRD2thWaveName+"_1D")
	string sPeakXlocations = ""
	for(iPeakList=0; iPeakList<ItemsInList(s2thList); iPeakList+=1)
		variable vCurrentPeak2th = str2num(stringFromList(iPeakList, s2thList))
		FindLevel/Q wOneD2th vCurrentPeak2Th
		sPeakXlocations += num2Str(Round(V_LevelX))+";"
	endFor
	variable v2thPerX = wOneD2th[1] - wOneD2th[0]
	
	
	variable iResidualIndex, iFittedPeak
	// At each point on the sample
	for(iSampleNumber=0; iSampleNumber<vNumSamples; iSampleNumber+=1)
		// Extract single point XRD data
		wave wSinglePointXRD = $(ExtractASampleFromAVector(sFilePath+":"+sLibraryName, sXRDintWaveName, iSampleNumber, sXRDintWaveName+"_"+num2str(iSampleNumber)))
		
		// Generate guesses, fit. Capture Fit error, if any
		string sFittedPeaks = singleTraceXRDParamGenerator(wSinglePointXRD,sPeakXlocations,vWindowSize=vWindowSize,vFwhmGuess=vFwhmGuess, vMaxFwhm=vMaxFwhm, vEpsPoly=vEpsPoly, vEpsAmp=vEpsAmp, vEpsFWHM=vEpsFWHM, vEpsCenter=vEpsCenter, vEpsFracGauss=vEpsFracGauss)
		wave W_coef = root:W_coef 
		wave/T T_Constraints = root:T_Constraints
		wave wEpsilon = root:wEpsilon
		variable V_FitError = 0
		FuncFit/Q AutoCubicPseudoVoigts W_coef wSinglePointXRD /D /R /E=wEpsilon /C=T_Constraints
		T_Constraints = ""
		wFitErrors[iSampleNumber] = V_FitError
		
		// Grab residuals, calculate proportional residual, put into 2D wave
		wave wSingleResid = $("root:"+"Res_"+nameOfWave(wSinglePointXRD))
		for(iResidualIndex=0; iResidualIndex<dimSize(wSingleResid,0); iResidualIndex+=1)
			wResiduals[iSampleNumber][iResidualIndex] = wSingleResid[iResidualIndex]/wSinglePointXRD[iResidualIndex]
		endFor
				
		// Add amorphous area to wave 
		Duplicate/O wSinglePointXRD $("root:XRD_PeakFit:Trash:AmoBG")
		wave wSinglePointBG = $("root:XRD_PeakFit:Trash:AmoBG")
		wSinglePointBG = W_coef[0] + x*W_coef[ItemsInList(sFittedPeaks)*4+1] + x^2*W_coef[ItemsInList(sFittedPeaks)*4+2] + x^3*W_coef[ItemsInList(sFittedPeaks)*4+3]
		wAmoBgAreas[iSampleNumber] = Area(wSinglePointBG)
				
		// Put trusted peak fit values into appropriate waves
		wave W_coef = root:W_coef
		wave W_sigma = root:W_sigma
		for(iFittedPeak=0; iFittedPeak<ItemsInList(sFittedPeaks); iFittedPeak+=1)
			variable vFittedPeak = str2num(stringFromList(iFittedPeak, sFittedPeaks))			
			
			variable vAmp = W_coef[4*vFittedPeak+1]
			variable vCenter2th = (W_coef[4*vFittedPeak+2] * v2thPerX) + wOneD2th[0]
			variable vFWHM = W_coef[4*vFittedPeak+3] * v2thPerX
			
			if(vFWHM>0 && vFWHM<10*vMaxFWHM && vAmp>0 && vCenter2th>0 && vCenter2th<waveMax(wOneD2th))
				wave wAmp = wOutputWaveRefs[vFittedPeak*6+0]
				wave wCenter = wOutputWaveRefs[vFittedPeak*6+1]
				wave wFWHM = wOutputWaveRefs[vFittedPeak*6+2]
				wave wAmpErr = wOutputWaveRefs[vFittedPeak*6+3]
				wave wCenterErr = wOutputWaveRefs[vFittedPeak*6+4]
				wave wFwhmErr = wOutputWaveRefs[vFittedPeak*6+5]
				
				wAmp[iSampleNumber] = vAmp
				wCenter[iSampleNumber] = vCenter2th
				wFWHM[iSampleNumber] = vFWHM
				if(v_FitError==0) // W_sigma does not update if the fit fails
					wAmpErr[iSampleNumber] = W_sigma[4*vFittedPeak+1]
					wCenterErr[iSampleNumber] = W_sigma[4*vFittedPeak+2]
					wFwhmErr[iSampleNumber] = W_sigma[4*vFittedPeak+3] * v2thPerX
				endIf
			endIf
			
			//clean up
			KillWaves/Z $("fit_"+sXRDintWaveName+"_"+num2str(iSampleNumber)), $("Res_"+sXRDintWaveName+"_"+num2str(iSampleNumber))
		endFor
		
		// Scale background wave
		if(!ParamIsDefault(vBgScaleLocation))
			// make new wave, populate
			Duplicate/O wAmoBgAreas $(GetWavesDataFolder(wAmoBgAreas,2)+"Scaled")
			wave wScaledBgAreas = $(GetWavesDataFolder(wAmoBgAreas,2)+"Scaled")
			wScaledBgAreas = wAmoBgAreas/vAvgBgScale	
		endIf		

		// Duplicate W_coefs and trusted peaks into special folder
		Duplicate/O root:W_Coef $("root:XRD_PeakFit:"+sLibraryName+":"+"Coef_"+num2str(iSampleNumber))
		//wLibraryTrustedPeaks[iSampleNumber] = sTrustedPeaks  TODO: delete this and the wave?
	endFor
	
	// Scale peak values
	if(vPeakAmpScaleType == 1)
		// find library max peak amp
		variable vScaleFactor = MaxPeakAmp(sFilePath+":XRD_PeakFit", sPeakNameList)
		// Cycle through peak amp + err waves, duplicate and scale
		ScalePeakAmps(sFilePath+":XRD_PeakFit", sPeakNameList, vScaleFactor)
	endIf
	
	// Display residuals 2D plot //eventual TODO: update color scheme
//	COMBIDisplay_Plot(sProjectName,"NewPlot","Vector",sLibraryName,sXRD2thWaveName,"","Linear","Auto","Auto","Bottom","Scalar","FromMappingGrid","Sample","","Linear","Auto","Auto","Left","Vector",sLibraryName,"XRD_PeakFit:Residuals","Linear","Auto","Auto","Rainbow","","","","Linear","Auto","Auto",3,10,"All","All","All","All","All","All")
//	TextBox/C/N=text0/F=0/A=MC sLibraryName
	
// Clean up TODO: trash folder
KillWaves/Z OneD2th,wSinglePointXRD, wOutputWaveRefs, $("root:Res_smoothXRD"), wSinglePointBG

End

///////////////////////////////////////////////
// input sFilePath - path to folder holding waves to be examined (should include folder name, waves should be sFilePath:PeakAmp_***)
// input sPeakNameList - string of peak names, i.e. labels appended to output waves (** in example above)
//
// output - highest value across all peak amp waves for the sample
// Returns the highest value across all peak amp waves for a particular sample
Function MaxPeakAmp(sFilePath, sPeakNameList)
	string sFilePath, sPeakNameList
	variable vMaxPeakAmp = 0, vNumPeaks = itemsInList(sPeakNameList)
	
	variable iPeak
	for(iPeak=0; iPeak<vNumPeaks; iPeak+=1)
		string sCurrentPeak = stringFromList(iPeak, sPeakNameList)
		wave wPeakAmp = $(sFilePath+":PeakAmp_"+sCurrentPeak)
		WaveStats/Q wPeakAmp
		vMaxPeakAmp = V_max>vMaxPeakAmp ? V_max : vMaxPeakAmp
	endFor
	return vMaxPeakAmp
End


///////////////////////////////////////////////
// input sFilePath - path to folder holding waves to be scaled (should include folder name, waves should be sFilePath:PeakAmp_***)
// input sPeakNameList - string of peak names, i.e. labels appended to output waves (** in example above)
// input vScaleFactor - value to divide input waves by
//
// Makes and populates scaled peak amp waves; waves will be DIVIDED by vScaleFactor
Function ScalePeakAmps(sFilePath, sPeakNameList, vScaleFactor)
	string sFilePath, sPeakNameList
	variable vScaleFactor
	
	variable iPeak, vNumPeaks = itemsInList(sPeakNameList)
	for(iPeak=0; iPeak<vNumPeaks; iPeak+=1)
		string sCurrentPeak = stringFromList(iPeak, sPeakNameList)
		wave wAmp = $(sFilePath+"PeakAmp_"+sCurrentPeak)
		variable vAmpWaveLength = numpnts(wAmp)
		make/O/N=(vAmpWaveLength) $(sFilePath+":ScaledAmp_"+sCurrentPeak)
		wave wScaledAmp = $(sFilePath+":ScaledAmp_"+sCurrentPeak)

		wave wAmpErr = $(sFilePath+"PeakAmpErr_"+sCurrentPeak)
		variable vErrWaveLength = numpnts(wAmpErr)
		make/O/N=(vErrWaveLength) $(sFilePath+":ScaledAmpErr_"+sCurrentPeak)
		wave wScaledAmpError = $(sFilePath+":ScaledAmpErr_"+sCurrentPeak)
		
		wScaledAmp = wAmp/vScaleFactor
		wScaledAmpError = wAmpErr/vScaleFactor
	endFor	
End


///////////////////////////////////////////////
// Assumes x-axis data in same library as y-axis data
// returns string of graph names created
Function/S XRDPeakFitPlotter(sFilePath, sLibraryList, sPeakList, sParamToGraph, sXaxis, sSeriesName [,vXmin, vXmax, vYmax, vYmin])
	string sFilePath, sLibraryList, sPeakList, sParamToGraph, sXaxis, sSeriesName
	variable vXmin, vXmax, vYmax, vYmin
	
	// Clean up input lists
	sPeakList = replaceString(",",sPeakList,";")
	sPeakList = replaceString(" ",sPeakList,"")
	sLibraryList = replaceString(",",sLibraryList,";")
	sLibraryList = replaceString(" ",sLibraryList,"")
	sSeriesName = replaceSTring(" ",sSeriesName,"")

	string sWindowNamesList = ""
	variable iPeakList, vNumPeaks=itemsInList(sPeakList)
	variable  iLibraryList, vNumLibraries=itemsInList(sLibraryList)
	variable vNumPlots = vNumPeaks==0? 1:vNumPeaks 

	for(iPeakList=0; iPeakList<vNumPlots; iPeakList+=1) 
		// for each peak
		string sCurrentPeak = stringFromList(iPeakList, sPeakList) 
		
		// make a graph window if necessary
		string sWindowName = sSeriesName+"_"+sParamToGraph+"_"+sCurrentPeak
		DoWindow $sWindowName
		if(!V_flag)
			Display/N=$sWindowName
		endif
		sWindowNamesList += sWindowName+";"
		
		// populate each graph with all libraries listed
		for(iLibraryList=0; iLibraryList<vNumLibraries; iLibraryList+=1)
			string sCurrentLibrary = stringFromList(iLibraryList, sLibraryList)
			
			if(vNumPeaks == 0)
				wave/Z wXaxis = $(sFilePath+":"+sCurrentLibrary+":"+sXaxis)
				wave/Z wYdata = $(sFilePath+":"+sCurrentLibrary+":XRD_PeakFit:"+sParamToGraph)
				wave/Z wYerr = $(sFilePath+":"+sCurrentLibrary+":XRD_PeakFit:"+sParamToGraph+"err")
			else
				wave/Z wXaxis = $(sFilePath+":"+sCurrentLibrary+":"+sXaxis)
				wave/Z wYdata = $(sFilePath+":"+sCurrentLibrary+":XRD_PeakFit:"+sParamToGraph+"_"+sCurrentPeak)
				wave/Z wYerr = $(sFilePath+":"+sCurrentLibrary+":XRD_PeakFit:"+sParamToGraph+"err_"+sCurrentPeak)
			endIf
			
			// check that x, y waves exist
			if(!waveExists(wXaxis))
				print "Wave "+sXaxis+" does not exist in "+sFilePath+":"+sCurrentLibrary
				break
			elseif(!waveExists(wYdata))
				print "Wave "+sParamToGraph+" does not exist in "+sFilePath+":"+sCurrentLibrary
			else
				// add trace to graph
				AppendToGraph/W=$sWindowName wYdata vs wXaxis
				// if possible, add error bars
				if(waveExists(wYerr))
					if(iLibraryList==0)
						string sTraceName = sParamToGraph+"_"+sCurrentPeak
					else
						sTraceName = sParamToGraph+"_"+sCurrentPeak+"#"+num2str(iLibraryList)
					endIf 
					ErrorBars/W=$sWindowName $sTraceName Y, wave=(wYerr, wYerr)
				endIf
			endIf
			
		endFor
		ModifyGraph mode=3, msize=3.5
		
		// annotation
		string sTextBox = sParamToGraph +" "+ sCurrentPeak
		TextBox/C/N=text0/F=0/A=MC sTextBox
		
		// axes 
		Label bottom sXaxis
		if(ParamIsDefault(vXmin) && !ParamIsDefault(vXmax))
			SetAxis bottom *, vXmax
		elseif(!ParamIsDefault(vXmin) && ParamIsDefault(vXmax))
			SetAxis bottom vXmin, *
		elseif(!ParamIsDefault(vXmin) && !ParamIsDefault(vXmax))
			SetAxis bottom vXmin, vXmax
		endIf
		
		Label left sParamToGraph
		if(ParamIsDefault(vYmin) && !ParamIsDefault(vYmax))
			SetAxis left *, vYmax
		elseif(!ParamIsDefault(vYmin) && ParamIsDefault(vYmax))
			SetAxis left vYmin, *
		elseif(!ParamIsDefault(vYmin) && !ParamIsDefault(vYmax))
			SetAxis left vYmin, vYmax
		endIf
		
	endFor

	return sWindowNamesList
	
End

///////////////////////////////////////////////
// For a collection of windows across which each nth trace should have the same color and/or marker
// color list should be n*(r,g,b) separated by ; with or without ()
Function StandardizeMarkersAndColors(sWindowList, [sMarkerNumberList, sColorList])
	string sWindowList, sMarkerNumberList, sColorList
	
	// Markers
	if(!ParamIsDefault(sMarkerNumberList))
		// Clean up input list
		sMarkerNumberList = replaceString(",",sMarkerNumberList,";")
		sMarkerNumberList = replaceString(" ",sMarkerNumberList,"")
		
		variable iWindowList, iTraceList
		//in each window
		for(iWindowList=0; iWindowList<itemsInList(sWindowList); iWindowList+=1)
			// check that number of markers matches with number of traces
			string sCurrentWindow = stringFromList(iWindowList,sWindowList)
			string sTraceList = traceNameList(sCurrentWindow,";",1)
			if(itemsInList(sTraceList) != itemsInList(sMarkerNumberList))
				Print "Window "+sCurrentWindow+" does not have the correct number of traces"
			else
				// modify the traces
				for(iTraceList=0; iTraceList<itemsInList(sTraceList); iTraceList+=1)
					string sCurrentTrace = stringFromList(iTraceList,sTraceList)
					ModifyGraph/W=$(sCurrentWindow) marker($sCurrentTrace)=str2num(stringFromList(iTraceList,sMarkerNumberList))
				endFor
			endIf
		endFor
	endIf

	// Colors
	if(!ParamIsDefault(sColorList))
		// clean up input color list
		sColorList = replaceString("(",sColorList,"")
		sCOlorList = replaceString(")",sColorList,"")
		// in each window
		for(iWindowList=0; iWindowList<itemsInList(sWindowList); iWindowList+=1)
			// check that number of markers matches with number of traces
			sCurrentWindow = stringFromList(iWindowList,sWindowList)
			sTraceList = traceNameList(sCurrentWindow,";",1)
			if(itemsInList(sTraceList) != itemsInList(sColorList))
				Print "Window "+sCurrentWindow+" does not have the correct number of traces"
			else
				// modify the traces
				for(iTraceList=0; iTraceList<itemsInList(sTraceList); iTraceList+=1)
					sCurrentTrace = stringFromList(iTraceList,sTraceList)
					variable r = str2num(stringFromList(0,stringFromList(iTraceList,sColorList),","))
					variable g = str2Num(stringFromList(1,stringFromList(iTraceList,sColorList),","))
					variable b = str2Num(stringFromList(2,stringFromList(iTraceList,sColorList),","))
					ModifyGraph/W=$(sCurrentWindow) rgb($sCurrentTrace)=(r,g,b)
				endFor
			endIf
		endFor
	endIf
	
End


/////////////////////////////////////
// input sFilePath - file path to location of libraries of interest, should include the folder (e.g. sFilePath:Library1:waves)
// input sLibraryList - list of libraries to fit and plot against each other, separated by ";"
// input s2thList - list of expected peaks locations in 2th
// input sPeakNameList - corresponding names for each value in s2thList (e.g. 021, substrate, etc)
// input sSeriesName - arbitrary name for the set of libraries being compared, used in plot title (eg. SubsTemp or Pressure or GrowthRate)
// input sXaxis - wave name of x-axis data for comparison plots, there should be a wave sFilePath:sLibraryName:sXaxis for each library in sLibraryList
// input vXmin - min X value in generated plots, defaults to 40
// input vXmax - max X value in generated plots, defaults to 80
// input vYmin - min Y value in generated plots, defaults to 0
// input vYmax - max Y value in generated plots, defaults to 6
// input vBgScaleLocation - if used, wave index of intensity value to use to scale background area (i.e. 0 to scale the area by the data height at the 0th data point)
// input vPeakAmpScaleType -  0 for no scaled values, 1 for scale by max amp in library
//
// output - string of plot names generated
//
// Fits the same set of peaks across several libraries, plots the resulting FWHM, peak amplitude, and background area for the set of libraries vs X value of your choice 
// Assumes XRD waves are kept in folders labeled with library name. All libraries must have the X wave of interest.
Function/S XrdCompare(sFilePath, sLibraryList, s2thList, sPeakNameList, sSeriesName, sXaxis[, vXmin, vXmax, vYmax, vYmin, vBgScaleLocation, vPeakAmpScaleType])
	string sFilePath, sLibraryList, s2thList, sPeakNameList, sSeriesName, sXaxis
	variable vXmin, vXmax, vYmax, vYmin,vBgScaleLocation, vPeakAmpScaleType
	
	// clean up input
	sLibraryList = replaceString(",",sLibraryList,";")
	s2thList = replaceString(",",s2thList,";")
	sPeakNameList = replaceString(",",sPeakNameList,";")
	
	vYmin = ParamIsDefault(vYmin)? 0 : vYmin
	vYmax = ParamIsDefault(vYmax)? 6 : vYmax
	vXmin = ParamIsDefault(vXmin)? 40 : vXmin
	vXmax = ParamIsDefault(vXmax)? 80 : vXmax
	
	
	variable iLibrary
	variable vNumLibraries = itemsInList(sLibraryList)
	string sPlotList = ""
	for(iLibrary=0; iLibrary<vNumLibraries; iLibrary+=1)
		string sLibraryName = stringFromList(iLibrary, sLibraryList)
		LibraryXRDPeakFit(sFilePath, sLibraryName, s2thList, sPeakNameList, vBgScaleLocation=vBgScaleLocation, vPeakAmpScaleType=vPeakAmpScaleType)
	endFor
	sPlotList += XRDPeakFitPlotter(sFilePath, sLibraryList, sPeakNameList, "FWHM", sXaxis, sSeriesName, vXmin=vXmin, vXmax=vXmax, vYmax=vYmax, vYmin=vYmin)
	sPlotList += XRDPeakFitPlotter(sFilePath, sLibraryList, sPeakNameList, "ScaledAmp", sXaxis, sSeriesName, vXmax=vXmax, vXmin=vXmin)
	sPlotList += XRDPeakFitPlotter(sFilePath, sLibraryList, "", "BackgroundArea", sXaxis, sSeriesName, vXmax=vXmax, vXmin=vXmin)
	
	return sPlotList
End

//////////////////
// Takes in a 2D wave, creates a 1D wave from a particular row from that 2D wave in the same file path
//
// input sFilePath - file path to wave of interest
// input sWaveName - name of 2D wave of interest
// input vRowNumber - row number to extract, indexed from 0
// input sDestWaveName - name of new wave to be created
//
// output - string of newly-created wave file path

Function/S ExtractASampleFromAVector(sFilePath, sWaveName, vRowNumber, sDestWaveName)
    string sFilePath, sWaveName, sDestWaveName
    variable vRowNumber
   
   //clean up input
   variable vFilePathLength = strLen(sFilePath)
   if(stringMatch(sFilePath[vFilePathLength-1], ":"))
   	sFilePath = sFilePath[0,vFilePathLength-1]
   endIf 
   
    //get vector wave
    wave wSourceWave = $(sFilePath +":"+sWaveName)
    if(!waveExists(wSourceWave))
           print "Wave" +sFilePath+":"+sWaveName+ "does not exist"
           return ""
    endIf       

    //make new wave in given folder
    int vOutputLength = dimSize(wSourceWave,1)//vector length
    Make/O/N=(vOutputLength) $(sFilePath+":"+sDestWaveName)
    wave wDestWave = $(sFilePath+":"+sDestWaveName)      

    //fill wave with data from sample
    wDestWave[] = wSourceWave[vRowNumber][p]     

    //return wave path and name
    return sFilePath+":"+sDestWaveName

End